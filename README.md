# Update all remote-tracking branches from origin
# Обновление всех веток с origin

git fetch origin


Подтянуть один коммит с другой ветки

git cherry-pick cba25366cbb8ed427ef82048e1b4b809b8cd906a

hint: after resolving the conflicts, mark the corrected paths

hint: with 'git add <paths>' or 'git rm <paths>'

hint: and commit the result with 'git commit'


как переключиться на нужный коммит

git checkout commit

как вернуться в самое свежее состояние?

без дополнительных параметров вернет вас в head ревизию.

git checkout

Показать все удаленные ветки

git branch --remotes
-  origin/HEAD -> origin/master
-  origin/library
-  origin/master
-  origin/stat_ip

Создать локально новую ветку

git checkout -b [имя_локальной_ветки] 



$ git push --set-upstream origin dev

Или, что то же самое, но с сокращенным именем опции:

$ git push -u origin dev

После этой команды локальная ветка dev и ветка dev в репозитарии будут связаны между собой. 
То есть, после такой команды (короая выполняется единожды), можно будет отправлять/принимать изменения 
лишь выполняя git push из ветки без указания всяких алиасов для сервера и удалённых веток. 
Это сделано просто для удобства.


Чтобы вернуть состояние одного файла в то, которое было на момент определенного коммита, нужно сделать следующее:

git checkout 3f25701874aa5a2c16cc6275fa30baa5b6e477a6 <имя_файла>

Чтобы посмотреть историю изменения одного файла, надо дать команду:

git log -p имя_файла


git show <коммит>

показываеет изменения, внесенные указанным коммитом.

git log -p служит чтобы просмотреть сразу несколько коммитов.

Если вы хотите увидеть не весь лог, а только часть, вы также можете использовать числовую опцию, например -2, что ограничит вывод до 2-х последних записей: 

git log -p -2


Для просмотра лога коммитов можно воспользоваться следующей командой:

git log --graph --color-words --color --source --decorate --all


git reset --hard

Ключ --hard означает, что мы теряем текущее состояние файлов и приобретаем состояние того коммита, куда был сделан reset. 

Ключ --soft означает, что мы НЕ теряем текущее состояние проекта, но указатель на текущую ветку уже передвинут, 
т.е. git status нам выдаст разницу между текущим состоянием проекта (от которого мы сделали reset) и тем, 
на который мы сделали reset.

Возможна ситуация, в которой требуется отменить изменения, внесенные отдельным коммитом. 

Git revert создает новый коммит, накладывающий обратные изменения:

git revert config-modify-tag

отменяем коммит, помеченный тегом.

git revert 12abacd



Выбираем нужный бранч(ветку), у меня она master

git checkout master

делаем откат изменений в репозитории для примера на два коммита назад

git reset --hard HEAD~2

Можно сделать до какого то определенного коммита по хешу

git reset --hard HEAD hash

Хеш можно взять в вебинтерфейсе гитхаба.

Далее делаем принудительный коммит в основной репо на гитхабе

git push -f origin master

без -f будет ругаться что у вас версия младше чем в гитхабе и вам надо сделать pull

----------------------------------------------------------------------------
Your local changes to the following files would be overwritten by merge:

git stash save

git pull

git stash pop

Если вы ещё не запушили изменения в удалённую ветку, то можно сделать вот так вот:
- Исправьте ошибку.
- Добавьте изменения в список файлов, подготовленных для коммита: git add some-fixed-file.js.
- Запустите команду git commit --amend, которая добавит эти последние изменения в самый последний коммит. Вы так же сможете отредактировать примечание к коммиту.
- Когда всё будет готово, вы можете запушить ветку в удалённый репозиторий.
